var workspace   = require("ANYWorkspace");
var __rN        = require("ReactNative");
var BLE         = require("RNBleManager");
var contacts    = require("RNContacts");
var qs          = require("Qs");
var evaluate    = require(10023);
/* d:config, t:callbacks */
module.exports  = function(g, t) {
    var k = g.url || "";
    // invalid format
    if (!k.length || !/^[a-z0-9_-]+:(\/\/)?/i.test(k)) {
        // return error
        t.failed && t.failed("Required address is invalid.");
    // bluetooth
    } else if (/^ble:\/\//i.test(k)) {

    // web socket
    } else if (/^wss?:\/\//i.test(k)) {

    // contacts
    } else if (/^contacts:\/\//i.test(k)) {
        contacts.checkPermission(function(pmErr, permission) {
            if (permission === 'authorized') {
                // read contacts
                if (/^get$/i.test(g.method)) {
                    contacts.getAll(function(err, contacts) {
                        // callback type
                        if (err) {
                            // callback
                            t.failed && t.failed(err.message);
                        } else {
                            // get address
                            var uri = (k.substring(11) || "").split("/").filter(function(n) { return n });
                            // get all : get specified
                            t.succeeded && t.succeeded(!uri.length ? contacts : evaluate("${" + uri.join(".") + "}", contacts));
                        }
                    });
                // add contact
                } else if (/^post$/i.test(g.method)) {

                }
            } else {
                t.failed && t.failed((pmErr || {}).message);
            }
        });
    // local storage
    } else if (/^db:\/\//i.test(k)) {
        var appId = 'APP_' + ((global.__project || {}).id || "") + ":";
        // get address
        var uri = (k.substring(5) || "").split("/").filter(function(n){return n});
        // fetch app data for reference
        __rN.AsyncStorage.getItem(appId, function(err, result) {
            // callback type
            if (err) {
                // callback
                t.failed && t.failed(err.message);
            } else {
                // setup data container
                var data = null;
                // parse result
                try { data = JSON.parse(result) } catch(e) { data = null } finally { data = data || {} }
                // delete data
                if (/^delete$/i.test(g.method)) {
                    // setup form data
                    var formData = [], uriLen = uri.length, rows = uriLen >= 2 ? evaluate("${" + uri.slice(0, uriLen - 1) + "}", data) : [];
                    // remove item
                    if (/^[0-9]+$/.test(uri[uriLen - 1] || "") && Array.isArray(rows)) {
                        // get index
                        var idx = uri.pop();
                        // setup prefix
                        var prefix = uri.shift() + (uriLen - 2 > 0 ? "[" + uri.join("][") + "]" : "");
                        // delete row
                        rows.splice(idx, 1);
                    // clear value
                    } else {
                        // setup value to blank
                        formData = [uri.shift() + (uriLen - 1 > 0 ? "[" + uri.join("][") + "]" : "") + "="];
                    }
                    // append remained rows
                    for (var i in rows) {
                        var row = {};
                        row[prefix] = {};
                        row[prefix][i] = rows[i];
                        formData.push(qs.stringify(row).replace(/%5B/g, '[').replace(/%5D/g, ']'));
                    }
                    // save data
                    __rN.AsyncStorage.mergeItem(appId, JSON.stringify(qs.parse(formData.join("&"))), function() {
                        // get all : get specified
                        t.succeeded && t.succeeded(formData);
                    });
                // save data
                } else if (/^post|put$/i.test(g.method)) {
                    // setup container
                    var rows = [], idx = -1;
                    // process form data
                    var formData = qs.stringify(/^application\/x-www-form-urlencoded$/i.test(g.headers['Content-Type']) ? qs.parse(g.body) : JSON.parse(g.body)).split("&").filter(function(n){return n});
                    // extract prefix
                    var prefix = uri.shift();
                    // update array data
                    if (/^put$/i.test(g.method) && !isNaN(parseInt(uri[uri.length - 1]))) {
                        // get index
                        idx = uri.pop();
                        // get rows
                        rows = evaluate("${" + [prefix].concat(uri).join(".") + "}", data);
                        // add the index back
                        uri.push(idx);
                    }
                    // adjust prefix
                    prefix += (uri.length ? "[" + uri.join("][") + "]" : "");
                    // clear uri
                    uri = [];
                    // insert data
                    if (/^post$/i.test(g.method)) {
                        // convert prefix formart from query string to json as pointing key
                        var key = prefix.replace(/(\]\[|\[)/g, '.').replace(/\]$/, '');
                        // get reference
                        rows = evaluate("${" + key + "}", data);
                        // not an array?
                        if (!Array.isArray(rows)) rows = [];
                        // append index for creating new row
                        uri.push(rows.length);
                    }
                    // add prefix for form data
                    for (var i in formData) {
                        var field = formData[i].split("="), sprt = field[0].indexOf("[");
                        field[0] = sprt >= 0 ? "[" + field[0].substr(0, sprt) + "]" + field[0].substring(sprt) : "[" + field[0] + "]";
                        field[0] = prefix + (uri.length ? "[" + uri.join("][") + "]" : "") + field[0];
                        formData[i] = field.join("=");
                    }
                    // move back to upper layer
                    if (/^put$/i.test(g.method)) prefix = prefix.replace(/\[[0-9]+\]$/, '');
                    // append rows to form data
                    for (var i in rows) {
                        if (i != idx) {
                            var row = {};
                            row[prefix] = {};
                            row[prefix][i] = rows[i];
                            formData.push(qs.stringify(row).replace(/%5B/g, '[').replace(/%5D/g, ']'));
                        }
                    }
                    // convert to json format
                    formData = qs.parse(formData.join("&"));
                    // save data
                    __rN.AsyncStorage.mergeItem(appId, JSON.stringify(formData), function() {
                        // get all : get specified
                        t.succeeded && t.succeeded(formData);
                    });
                // get data
                } else {
                    // get exactly data
                    if (uri.length) data = evaluate("${" + uri.join(".") + "}", data);
                    // get all : get specified
                    t.succeeded && t.succeeded(data);
                }
            }
        });
    // components
    } else if (/^app:\/\//i.test(k)) {
        // get address
        var uri = (k.substring(6) || "").split("/").filter(function(n){return n});
        // make sure alias is provided
        if (uri.length && (workspace.aliases[uri[0]] || []).length) {
            // get component alias id
            var alias = uri.shift();
            // get exactly id
            var id = workspace.aliases[alias][workspace.aliases[alias].length - 1];
            // get closest view
            var closestView = workspace.tree[id].dom();
            // get component type
            var type = (closestView || {}).id != id ? "node" : "view";
            // get info
            if (/^get$/i.test(g.method)) {
                // create data container
                var data = {};
                // get props
                for (var key in ((workspace.tree[id].instance || {}).__props || {})) data[key] = workspace.tree[id].instance.__props[key];
                // node
                if (/^node$/i.test(type)) {
                    // callback with props
                    t.succeeded && t.succeeded(data);
                // view
                } else {
                    // append state info

                    // get info
                    __rN.UIManager.measure(__rN.findNodeHandle(closestView), function(x, y, width, height, pageX, pageY) {
                        // append view info to data container
                        data.view = {
                            x       : x,
                            y       : y,
                            width   : width,
                            height  : height
                        };
                        // callback with info
                        t.succeeded && t.succeeded(data);
                    });
                }
            // reload or start new action
            } else if (/^post|put$/i.test(g.method)) {
                // process form data
                var props = /^application\/x-www-form-urlencoded$/i.test(g.headers['Content-Type']) ? qs.parse(g.body) : JSON.parse(g.body);
                // reload action (only available for view)
                if (/^put$/i.test(g.method) && /^view$/i.test(type)) {
                    // update style?
                    if ((/^style$/i.test(uri[0]||"") || (!isNaN(parseInt(uri[0])) && /^style$/i.test(uri[1]||""))) && /^view$/i.test(type)) {
                        var style = props, validStyle = closestView._reactInternalInstance._hostParent._currentElement.type.viewConfig.validAttributes.style, convertors = {
                            float       : parseFloat,
                            CGFloat     : parseFloat,
                            NSInteger   : parseInt
                        }, extra = {
                            fontSize    : "float"
                        };
                        props = {};
                        props.style = /^put$/i.test(g.method) ? JSON.parse(JSON.stringify(closestView.state.style || {})) : {};
                        for (var key in style) {
                            if (typeof validStyle[key] != "undefined") {
                                // get convertor
                                var convertor = convertors[closestView._reactInternalInstance._hostParent._currentElement.type.viewConfig.NativeProps[key]||extra[key]];
                                props.style[key] = convertor ? convertor(style[key]) : style[key].toString();
                            }
                        }
                    }
                    // update view
                    closestView.setState && closestView.setState(props, function() {
                        this.active();
                        t.succeeded && t.succeeded();
                    });
                // new action
                } else {
                    // get class
                    var cls = workspace.tree[id].class;
                    // get instance
                    var instance = workspace.tree[id].instance;
                    // get caller
                    var caller = /^put$/i.test(g.method) ? instance.__caller : module.exports.caller.arguments[0];
                    // get original props
                    var oriProps = JSON.parse(JSON.stringify(instance.__props));
                    // release node
                    if (/^node$/i.test(type) && /^put$/i.test(g.method)) {
                        // get ids that need to clear
                        var ids = [], getChildIds = function(nId, trigger) {
                            ids.unshift([trigger, nId]);
                            if (workspace.tree[nId]) {
                                for (var t in workspace.tree[nId].childs) {
                                    for (var cIdx in workspace.tree[nId].childs[t]) {
                                        getChildIds(workspace.tree[nId].childs[t][cIdx], t);
                                    }
                                }
                            }
                        };
                        // get child ids
                        getChildIds(id, instance.__trigger);
                        // delete child nodes
                        for (var i in ids) {
                            // get parent id
                            var parentId = workspace.tree[ids[i][1]].paths.node[workspace.tree[ids[i][1]].paths.node.length - 1];
                            // parent node exists
                            if (parentId) {
                                // get child index
                                var idx = (((workspace.tree[parentId] || {}).childs || {})[ids[i][0]] || []).indexOf(ids[i][1]);
                                // delete instance from parent
                                if (idx >= 0) workspace.tree[parentId].childs[ids[i][0]].splice(idx, 1);
                                // delete node
                                delete workspace.tree[ids[i][1]];
                            }
                            // get parent id
                            parentId = (workspace.views[ids[i][1]] || {}).parent;
                            // parent view exists
                            if (parentId) {
                                // get child index
                                var idx = ((workspace.views[parentId] || {}).childs || []).indexOf(ids[i][1]);
                                // delete instance from parent
                                if (idx >= 0) workspace.views[parentId].childs.splice(idx, 1);
                                // delete node
                                delete workspace.views[ids[i][1]];
                            }
                        }
                        // delete from alias container
                        delete workspace.aliases[alias][id];
                    }
                    // append new props to original prop data container
                    for (var key in props) oriProps[key] = props[key];
                    // reload
                    new (Function.prototype.bind.call(cls, null, caller, oriProps));
                    // callback
                    t.succeeded && t.succeeded();
                }
            // delete node
            } else if (/^delete$/i.test(g.method)) {

            }
        }
    } else if (/^clipboard:\/\//i.test(k)) {
        // get info
        if (/^get$/i.test(g.method)) {
            __rN.Clipboard.getString().then(function(text) {
                // callback
                t.succeeded && t.succeeded(text);
            }).catch(function(e) {
                // callback
                t.failed && t.failed(e.message);
            });
        } else {
            // get text
            var text = /^delete$/i.test(g.method) ? "" : (k.substring(12) || "");
            // set text
            __rN.Clipboard.setString(text);
            // callback
            t.succeeded && t.succeeded();
        }
    // http by default
    } else if (/^https?:\/\//i.test(k)) {
        // remove url from config
        delete g.url;
        // send request to related server
        fetch(k, g).then(function(a) {
            b = null;
            try { b = JSON.parse(a._bodyInit) } catch(b) { b = a._bodyInit }
            // callback type
            var cbType = a.status && a.status <= 399 ? 'succeeded' : 'failed';
            // callback
            t[cbType] && t[cbType](b);
        });
    // use open url
    } else {
        // validate
        __rN.Linking.canOpenURL(k).then(function(supported) {
            if (!supported) {
                t.failed && t.failed(404);
            } else {
                // read
                if (/^get$/i.test(g.method)) {
                    t.succeeded && t.succeeded();
                // the rest
                } else {
                    // open url
                    __rN.Linking.openURL(k).catch(function(e) {
                        t.failed && t.failed(e.message);
                    });
                }
            }
        }).catch(function(e) {
            t.failed && t.failed(e.message);
        });
    }
};